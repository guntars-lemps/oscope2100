#include "oscope2100_common.h"
#include "oscope2100_interface.h"
#include "oscope2100_usb.h"

#include <iomanip>
#include <sstream>
#include <fstream>
#include <math.h>
#include <sys/stat.h>
#include <stdlib.h>
#include <stdio.h>


#include "ConfigFile.h"


void load_settings()
{
  std::string defdir=getenv("HOME");
  defdir+="/.oscope2100";
  struct stat st;
  if (stat(defdir.c_str(),&st)!=0)
  {
    //std::cout << "Dir not exists, creating "<<std::endl;
    mkdir (defdir.c_str(),0755);
  }
  std::string filename=defdir+"/last.cfg";
  FILE *file;
  if ((file=fopen(filename.c_str(),"a"))==NULL)
  {
    std::cout <<"Cannot open or create file "<<filename<<std::endl;
    exit(1);
  }
  fclose(file);
  ConfigFile config(filename);
  //
  int tmpint;
  double tmpd;
  config.readInto(tmpint,"mode",int(MODE_NORMAL));
  switch (tmpint)
  {
    case MODE_NORMAL:ui_mode=MODE_NORMAL;break;
    case MODE_FZOOM:ui_mode=MODE_FZOOM;break;
    case MODE_XY:ui_mode=MODE_XY;break;
    default:ui_mode=MODE_NORMAL;
  }
  config.readInto(ui_time,"time",9);
  if (ui_time<0) ui_time=0;
  if (ui_time>=TCOUNT) ui_time=TCOUNT-1;
  //
  config.readInto(tmpint,"ch1_on",1);
  ui_ch1_on=(tmpint!=0);
  config.readInto(tmpint,"ch1_flip",0);
  ui_ch1_flip=(tmpint!=0);
  config.readInto(ui_ch1_voltage,"ch1_voltage",5);
  if (ui_ch1_voltage<0) ui_ch1_voltage=0;
  if (ui_ch1_voltage>=VCOUNT) ui_ch1_voltage=VCOUNT-1;
  config.readInto(tmpint,"ch1_mode",int(CHMODE_DC));
  switch (tmpint)
  {
    case CHMODE_DC:ui_ch1_mode=CHMODE_DC;break;
    case CHMODE_AC:ui_ch1_mode=CHMODE_AC;break;
    case CHMODE_GND:ui_ch1_mode=CHMODE_GND;break;
    default:ui_ch1_mode=CHMODE_DC;
  }
  config.readInto(tmpint,"ch1_mul",int(X1));
  switch (tmpint)
  {
    case X1:ui_ch1_mul=X1;break;
    case X10:ui_ch1_mul=X10;break;
    case X100:ui_ch1_mul=X100;break;
    default:ui_ch1_mul=X1;
  }
  //
  config.readInto(tmpint,"ch2_on",1);
  ui_ch2_on=(tmpint!=0);
  config.readInto(tmpint,"ch2_flip",0);
  ui_ch2_flip=(tmpint!=0);
  config.readInto(ui_ch2_voltage,"ch2_voltage",5);
  if (ui_ch2_voltage<0) ui_ch2_voltage=0;
  if (ui_ch2_voltage>=VCOUNT) ui_ch2_voltage=VCOUNT-1;
  config.readInto(tmpint,"ch2_mode",int(CHMODE_DC));
  switch (tmpint)
  {
    case CHMODE_DC:ui_ch2_mode=CHMODE_DC;break;
    case CHMODE_AC:ui_ch2_mode=CHMODE_AC;break;
    case CHMODE_GND:ui_ch2_mode=CHMODE_GND;break;
    default:ui_ch2_mode=CHMODE_DC;
  }
  config.readInto(tmpint,"ch2_mul",int(X1));
  switch (tmpint)
  {
    case X1:ui_ch2_mul=X1;break;
    case X10:ui_ch2_mul=X10;break;
    case X100:ui_ch2_mul=X100;break;
    default:ui_ch2_mul=X1;
  }
  //
  config.readInto(tmpint,"trigger",int(TR_OFF));
  switch (tmpint)
  {
    case 0:ui_trigger=TR_OFF;break;
    case 1:ui_trigger=TR_CH1;break;
    case 2:ui_trigger=TR_CH2;break;
    case 3:ui_trigger=TR_EXT;break;
    default:ui_trigger=TR_OFF;
  }
  config.readInto(ui_edge,"edge",0);
  //
  config.readInto(tmpint,"scientific",1);
  ui_scientific_format=(tmpint!=0);
  config.readInto(tmpint,"separator",0x09);
  ui_separator=tmpint;
  //
  config.readInto(tmpint,"math",int(M_OFF));
  switch (tmpint)
  {
    case 0:ui_math=M_OFF;break;
    case 1:ui_math=M_CH1V_CH2I;break;
    case 2:ui_math=M_CH1I_CH2V;break;
    case 3:ui_math=M_CH1I;break;
    case 4:ui_math=M_CH2I;break;
    default:ui_math=M_OFF;
  }
  config.readInto(tmpd,"rshunt",0.0);
  ui_rshunt=tmpd;
  config.readInto(tmpd,"rload",0.0);
  ui_rload=tmpd;
  refresh_ch_k();
}


void save_settings()
{
  struct stat st;
  //
  std::string defdir=getenv("HOME");
  defdir+="/.oscope2100";
  if (stat(defdir.c_str(),&st)!=0)
  {
    //std::cout << "Dir not exists, creating "<<std::endl;
    mkdir (defdir.c_str(),0755);
  }
  //
  std::string filename=defdir+"/last.cfg";
  std::ofstream out(filename.c_str(), std::ios::out | std::ios::binary);
  if (!out)
  {
    std::cout << "Cannot open file "<<filename<<std::endl;
  }
  else
  {
    out<<"# Do not edit, file automatically generated by 'Oscope2100' !!!"<<std::endl;
    out<<std::endl;
    out<<"# Time and mode settings"<<std::endl;
    out<<"mode="<<ui_mode<<std::endl;
    out<<"time="<<ui_time<<std::endl;
    out<<std::endl;
    //
    out<<"# CH1 settings"<<std::endl;
    out<<"ch1_on="<<ui_ch1_on<<std::endl;
    out<<"ch1_flip="<<ui_ch1_flip<<std::endl;
    out<<"ch1_voltage="<<ui_ch1_voltage<<std::endl;
    out<<"ch1_mode="<<ui_ch1_mode<<std::endl;
    out<<"ch1_mul="<<ui_ch1_mul<<std::endl;
    out<<std::endl;
    //
    out<<"# CH2 settings"<<std::endl;
    out<<"ch2_on="<<ui_ch2_on<<std::endl;
    out<<"ch2_flip="<<ui_ch2_flip<<std::endl;
    out<<"ch2_voltage="<<ui_ch2_voltage<<std::endl;
    out<<"ch2_mode="<<ui_ch2_mode<<std::endl;
    out<<"ch2_mul="<<ui_ch2_mul<<std::endl;
    out<<std::endl;
    //
    out<<"# Trigger settings"<<std::endl;
    out<<"trigger="<<ui_trigger<<std::endl;
    out<<"edge="<<ui_edge<<std::endl;
    out<<std::endl;
    //
    out<<"# Exporting settings"<<std::endl;
    out<<"scientific="<<ui_scientific_format<<std::endl;
    out<<"separator="<<int(ui_separator)<<std::endl;
    out<<std::endl;
    //
    out<<"# Math settings"<<std::endl;
    out<<"math="<<int(ui_math)<<std::endl;
    out<<"rshunt="<<f2str(ui_rshunt)<<std::endl;
    out<<"rload="<<f2str(ui_rload)<<std::endl;
    //
    out.close();
  }
}

std::string fround4 (double x)
{
  int p1=0;
  while ((fabs(x)<1000) && (p1>-12)) {x*=10;p1--;}
  while ((fabs(x)>=10000) && (p1<12)) {x/=10;p1++;}
  x=round(x);
  //
  std::ostringstream strs;
  strs<<f2str(x*pow(10,p1));
  return strs.str();
}


std::string val2str (double x,std::string unit,bool allow_decimals)
{
  int p1=0;
  //std::cout<<x<<std::endl;
  while ((fabs(x)<100) && (p1>-12)) {x*=10;p1--;}
  while ((fabs(x)>=1000) && (p1<12)) {x/=10;p1++;}
  if ((p1>=12) || (p1<=-12)) {x=0;p1=0;}
  x=round(x);
  double intpart;
  int p2=0;
  while ((fabs(x)>0) && (fabs(modf(x/10,&intpart))<0.01)) {x=round(x/10);p2++;}
  //std::cout<<x<<" p1="<<p1<<" p2="<<p2<<std::endl;
  //
  std::ostringstream strs;
  if (((p1+p2)>=6) || (allow_decimals && (p1>3)))
  {
    strs<<(x*pow(10,p1+p2-6))<<""<<"M"<<unit;
    return strs.str();
  }
  if (((p1+p2)>=3) || (allow_decimals && (p1>0)))
  {
    strs<<(x*pow(10,p1+p2-3))<<""<<"K"<<unit;
    return strs.str();
  }
  if (p1<=-9)
  {
    strs<<(x*pow(10,p1+p2+9))<<""<<"n"<<unit;
    return strs.str();
  }
  if (p1<=-6)
  {
    strs<<(x*pow(10,p1+p2+6))<<""<<"u"<<unit;
    return strs.str();
  }
  if (p1<=-3)
  {
    strs<<(x*pow(10,p1+p2+3))<<""<<"m"<<unit;
    return strs.str();
  }
  strs<<(x*pow(10,p1+p2))<<""<<unit;
  return strs.str();
}

std::string f2str(double f,bool sc)
{
  std::ostringstream tmp;
  if (sc) // scientific format
  {
    tmp<<std::uppercase<<std::scientific<<std::setprecision(12)<<f;
    std::string rez=tmp.str();
    //
    std::string::size_type epos=rez.find_last_of("E");
    std::string::size_type zpos=rez.find_last_not_of("0",epos-1);
    if ((zpos>0) && (rez.at(zpos)=='.')) zpos--;
    rez.erase(zpos+1,epos-zpos-1);
    return rez;
  }
  else
  {
    tmp<<std::fixed<<std::setprecision(12)<<f;
    std::string rez=tmp.str();
    //
    std::string::size_type zpos=rez.find_last_not_of("0");
    if ((zpos>0) && (rez.at(zpos)=='.')) zpos--;
    rez.erase(zpos+1);
    return rez;
  }
}

std::string pad(std::string s,unsigned int n)
{
  while (s.length()<n) s+=" ";
  return s;
}


bool prepare_expstr()
{
  uchar separator=ui_separator;
  //
  expstr.str("");
  if (ui_ch1_on || ui_ch2_on)
  {
    expstr<<"Time(s)";
    if (ui_ch1_on) expstr<<separator<<"CH1(V)";
    if (ui_ch2_on) expstr<<separator<<"CH2(V)";
    expstr<<std::endl;
    //
    int b;
    double ch1o;
    double ch2o;
    ch1o=ch1_offset;
    ch2o=ch2_offset;
    //
    if (ui_ch1_flip) {if (ch1o>=0xfe) ch1o=0; else ch1o=(0xfe)-ch1o;}
    if (ui_ch2_flip) {if (ch2o>=0xfe) ch2o=0; else ch2o=(0xfe)-ch2o;}
    //
    for (int n=0;n<BUFSIZE;n++)
    {
      // time
      expstr<<f2str((1.0*n*SCOPE_TIME[buf_time])/(SFREQ),ui_scientific_format);
      // CH1
      if (ui_ch1_on)
      {
        b=ch1buf[n];
        if (ui_ch1_flip) {if (b==0xff) b=0; else b=(0xfe)-b;}
        expstr<<separator<<f2str((ch1_k*(b-ch1o)*8*VOLTAGE_RESOLUTION[buf_ch1])/256,ui_scientific_format);
      }
      // CH2
      if (ui_ch2_on)
      {
        b=ch2buf[n];
        if (ui_ch2_flip) {if (b==0xff) b=0; else b=(0xfe)-b;}
        expstr<<separator<<f2str((ch2_k*(b-ch2o)*8*VOLTAGE_RESOLUTION[buf_ch2])/256,ui_scientific_format);
      }
      expstr<<std::endl;
    }
  }
  return true;
}



int main (int argc, char **argv)
{
  cursor_x0=-1;
  cursor_y0=-1;
  cursor_x1=-1;
  cursor_y1=-1;
  load_settings();
  buf_ready=FALSE;
  scopestate=NONE;
  capture_mode=CM_AUTO;
  restart_capture=false;
  ch1_offset=0x7f;
  ch2_offset=0x7f;
  //
  usb_start();
  //
  gtk_set_locale ();
  gtk_init (&argc, &argv);
  create_interface();
  gtk_widget_show_all(GTK_WIDGET(window));
  // no data captured yet, hide graph labels
  gtk_widget_hide(ch1_label);
  gtk_widget_hide(ch2_label);
  gtk_widget_hide(time_label);
  gtk_widget_hide(x_info_label);
  gtk_widget_hide(y_info_label);
  gtk_widget_hide(demo_label);
  gtk_widget_hide(math_label);
  //
  gtk_main();
  usb_stop();
  save_settings();
  // deinit usb
  return 0;
}
